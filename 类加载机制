##1 类加载机制
1、加载
1）根据类限制名获取定义此类的二进制字节流；
Class文件获取方法：从Jar\Ear\WAR格式中获取；从网络上获取；运行时生成或是从数据库中获取
非数组类的加载：开发人员可通过自定义的类加载器去控制字节流的获取方式；
数组类的加载：数组本身是由Java虚拟机直接创建的，如果数组类的组件类型是引用类型，那就递归采用加载的过程去加载这个组件类型；若数组的组件类型不是引用类型，
Java虚拟机会把数组C标记为与引导类加载器关联。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
虚拟机外部的二进制字流按照虚拟机所需格式存储在方法区
3）在内存中生成一个代表此类的java.lang.Class对象，作为方法区此类的各种数据访问入口。

2、验证
验证类文件格式是否符合规范，不会影响虚拟机运行；

3、解析
将常量池中的符号引用转化为直接引用。
（1)符号引用（symbolic references)：
用一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义定位到目标即可。如在Class文件中它以Constant_class_info,
constant_fieldref_info, constant_methodref_info等类型的常量出现。符号引用与虚拟机布局无关，引用的目标并不一定加载到内存中。
（2）直接引用：
直接指向目标的指针（如指向类型、类变量、类方法的直接引用可能是指向方法区的指针）
相对偏移（如指向实例变量、实例方法的直接引用都是偏移量）
一个能间接定位到目标的名柄
直接引用和虚拟机的布局相关，如果有了直接引用，那引用的目标必定已加载入内存中了。
（3）四种常量类型的解析
1）类或接口：判断要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析
2）字段：先在本类查找是否包含有简单名称和字段描述都与目标匹配的字段，若有，则结束查找，没有，会按继承关系从上往下搜索。
3）类方法
4）接口方法

3、准备
为类变量分配内存空间并为初始化为零值。

4、连接

5、初始化
根据程序员通过程序指定的主观计划去初始化类变量和其他资源。它是执行类构造器方法的过程。

6、使用

7、卸载
1）加载此类的classLoader已被卸载

